---
layout: post
title: "[BOJ 28279] 덱 2"
date: 2026-02-06
excerpt: "백준 문제 풀이"
categories: [Algorithm, BOJ]
tags: [python, deque, sys, stdin, stdout, implementation]
---

## 문제 요약

정수를 저장하는 덱(deque)을 구현하고, N개의 명령을 처리한다. (N ≤ 1,000,000)

- `1 X`: 앞에 넣기
- `2 X`: 뒤에 넣기
- `3`: 앞에서 빼고 출력 (없으면 -1)
- `4`: 뒤에서 빼고 출력 (없으면 -1)
- `5`: 크기 출력
- `6`: 비었으면 1, 아니면 0
- `7`: 앞 값 출력 (없으면 -1)
- `8`: 뒤 값 출력 (없으면 -1)

입력/출력량이 많아서 **빠른 I/O + 출력 버퍼링**이 핵심이다.

---

## 내가 작성한 코드 (정답)

```python
import sys
from collections import deque

input = sys.stdin.readline

dq = deque()
out = []

n = int(input())

for _ in range(n):
    order = input().strip()
    if order[0] == '1':
        dq.appendleft(order[2:])
    elif order[0] == '2':
        dq.append(order[2:])
    elif order == '3':
        if not dq:
            out.append(-1)
        else:
            out.append(dq.popleft())
    elif order == '4':
        if not dq:
            out.append(-1)
        else:
            out.append(dq.pop())
    elif order == '5':
        out.append(len(dq))
    elif order == '6':
        if not dq:
            out.append(1)
        else:
            out.append(0)
    elif order == '7':
        if not dq:
            out.append(-1)
        else:
            out.append(dq[0])
    elif order == '8':
        if not dq:
            out.append(-1)
        else:
            out.append(dq[-1])

print(*out, sep='\n', end='')
```

### 좋은 점
- `deque`를 사용해서 앞/뒤 삽입/삭제를 O(1)로 처리했다.
- 출력은 `out`에 모아 한 번에 출력해서 `print()` 반복 호출을 줄였다.
- `strip()`으로 개행 처리도 신경 썼다.

---

## 개선 포인트

### 1) 명령 파싱을 `split()`로 하면 조건문이 깔끔해진다
지금 코드는 `order[0]`(1/2)와 `order == '3'`(나머지)을 섞어서 처리한다. 동작은 맞지만, 읽는 사람이 “왜 어떤 건 [0]이고 어떤 건 전체 비교지?”가 헷갈릴 수 있다.

`split()`로 토큰화하면:
- 개행(`\n`) 처리를 별도로 신경 쓸 필요가 거의 없고
- `cmd`가 숫자라서 `if cmd == 3:`처럼 분기하기 쉬워진다.

### 2) 출력 리스트는 처음부터 문자열로 모아두면 더 안정적이다
지금은 `out`에 정수/문자열이 섞일 수 있는데, `print(*out)`은 괜찮아도
`'\n'.join(out)` 같은 방식으로 바꾸려면 문자열이어야 한다.

---

## 개선된 코드 (추천)

```python
import sys
from collections import deque

input = sys.stdin.readline

n = int(input())
dq = deque()
out = []

for _ in range(n):
    parts = input().split()
    cmd = int(parts[0])

    if cmd == 1:          # push_front
        dq.appendleft(int(parts[1]))
    elif cmd == 2:        # push_back
        dq.append(int(parts[1]))
    elif cmd == 3:        # pop_front
        out.append(str(dq.popleft() if dq else -1))
    elif cmd == 4:        # pop_back
        out.append(str(dq.pop() if dq else -1))
    elif cmd == 5:        # size
        out.append(str(len(dq)))
    elif cmd == 6:        # empty
        out.append('0' if dq else '1')
    elif cmd == 7:        # front
        out.append(str(dq[0] if dq else -1))
    else:                 # cmd == 8, back
        out.append(str(dq[-1] if dq else -1))

sys.stdout.write('\n'.join(out))
```

---

## 이 코드에서 배울 수 있는 점

- `input().split()`을 쓰면 개행(`\n`)을 포함한 공백 처리가 자동이라, `strip()` 없이도 파싱이 깔끔해진다.
- 덱은 `deque`로 구현하면 `append/appendleft/pop/popleft`가 모두 O(1)이라 앞/뒤 연산이 많은 문제에서 필수다.
- `if dq` / `if not dq`로 빈 자료구조 체크를 간단하게 할 수 있다.
- 출력은 `out`에 문자열로 모아 `\n`.join(...) 후 `sys.stdout.write`로 한 번에 출력하면, 대량 출력에서 안정적이다.
- 명령이 숫자로 들어오는 문제는 `cmd = int(parts[0])`로 받아 `cmd == 1,2,...` 형태로 분기하면 가독성이 좋아진다.

---
