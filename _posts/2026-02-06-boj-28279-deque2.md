---
layout: post
title: "[BOJ 28279] 덱 2"
date: 2026-02-06
excerpt: "백준 문제 풀이"
categories: [Algorithm, BOJ]
tags: [python, deque, sys, stdin, stdout, implementation]
---

## 문제 요약

정수를 저장하는 덱(deque)을 구현하고, N개의 명령을 처리한다. (N ≤ 1,000,000)

- `1 X`: 앞에 넣기
- `2 X`: 뒤에 넣기
- `3`: 앞에서 빼고 출력 (없으면 -1)
- `4`: 뒤에서 빼고 출력 (없으면 -1)
- `5`: 크기 출력
- `6`: 비었으면 1, 아니면 0
- `7`: 앞 값 출력 (없으면 -1)
- `8`: 뒤 값 출력 (없으면 -1)

입력/출력량이 많아서 **빠른 I/O + 출력 버퍼링**이 핵심이다.

---

## 개선된 코드 (추천)

```python
import sys
from collections import deque

input = sys.stdin.readline

n = int(input())
dq = deque()
out = []

for _ in range(n):
    parts = input().split()
    cmd = int(parts[0])

    if cmd == 1:          # push_front
        dq.appendleft(int(parts[1]))
    elif cmd == 2:        # push_back
        dq.append(int(parts[1]))
    elif cmd == 3:        # pop_front
        out.append(str(dq.popleft() if dq else -1))
    elif cmd == 4:        # pop_back
        out.append(str(dq.pop() if dq else -1))
    elif cmd == 5:        # size
        out.append(str(len(dq)))
    elif cmd == 6:        # empty
        out.append('0' if dq else '1')
    elif cmd == 7:        # front
        out.append(str(dq[0] if dq else -1))
    else:                 # cmd == 8, back
        out.append(str(dq[-1] if dq else -1))

sys.stdout.write('\n'.join(out))
```

---

## 이 코드에서 배울 수 있는 점

- `input().split()`을 쓰면 개행(`\n`)을 포함한 공백 처리가 자동으로 되어, `strip()` 없이도 파싱이 깔끔해진다.
- 덱은 `collections.deque`를 쓰면 `append/appendleft/pop/popleft`가 모두 O(1)이라, 앞/뒤 삭제가 잦은 문제에서 필수다.
- `if dq` / `if not dq`로 빈 자료구조 체크를 간단하게 할 수 있다.
- 출력은 `out`에 모아 `\n`.join(...) 후 `sys.stdout.write`로 한 번에 출력하면, `print()` 반복 호출보다 대량 출력에서 안정적이다.
- 명령이 숫자로 들어오는 문제는 `cmd = int(parts[0])`로 받아 `cmd == 1,2,...` 형태로 분기하면 오타/문자열 비교 실수를 줄일 수 있다.

---
