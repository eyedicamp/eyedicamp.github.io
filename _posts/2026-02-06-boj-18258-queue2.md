---
layout: post
title: "[BOJ 18258] 큐 2"
date: 2026-02-06
excerpt: "백준 문제 풀이"
categories: [Algorithm, BOJ]
tags: [python, queue, deque, sys, stdin, stdout, implementation]
---

## 문제 요약

정수 큐를 구현하고, N개의 명령을 처리한다. (N ≤ 2,000,000)

- `push X`: 뒤에 X 추가
- `pop`: 앞에서 제거 및 출력 (없으면 -1)
- `size`: 원소 개수
- `empty`: 비었으면 1, 아니면 0
- `front`: 맨 앞 값 (없으면 -1)
- `back`: 맨 뒤 값 (없으면 -1)

입력/출력량이 매우 커서 **빠른 I/O**가 핵심이다.

---

## 내가 작성한 코드 (정답)

```python
import sys
from collections import deque

input = sys.stdin.readline

out = []
dq = deque()

n = int(input())

for _ in range(n):
    order = input().strip()
    if order[:3] == "pus":
        dq.appendleft(order[5:])
    elif order[:3] == "pop":
        if not dq:
            out.append(-1)
        else:
            out.append(dq.pop())
    elif order[:3] == "siz":
        out.append(len(dq))
    elif order[:3] == "emp":
        if dq:
            out.append(0)
        else:
            out.append(1)
    elif order[:3] == "fro":
        if not dq:
            out.append(-1)
        else:
            out.append(dq[-1])
    elif order[:3] == "bac":
        if not dq:
            out.append(-1)
        else:
            out.append(dq[0])

print(*out, sep='\n', end='')
```

---

## 개선할 수 있는 점

### 1) `strip()`을 꼭 쓸 필요는 없다
`input().split()`을 쓰면 기본적으로 공백/개행이 처리되기 때문에, 명령 파싱이 더 깔끔해진다.

### 2) 큐 방향을 “정방향”으로 쓰면 더 직관적이다
현재 코드는 `appendleft` + `pop`으로 동작 자체는 맞지만, `front/back` 인덱스가 반대로 느껴질 수 있다.

일반적으로는:
- `push` → `dq.append(x)`
- `pop` → `dq.popleft()`
- `front` → `dq[0]`
- `back` → `dq[-1]`

처럼 쓰는 게 읽기 쉽다.

### 3) 출력은 문자열로 모아 `join` + `sys.stdout.write`가 안정적이다
`print()`를 N번 호출하면 느려질 수 있으니, 출력은 리스트에 모아서 한 번에 출력하는 패턴이 흔하다.

---

## 개선된 코드 (추천)

```python
import sys
from collections import deque

input = sys.stdin.readline

n = int(input())
dq = deque()
out = []

for _ in range(n):
    parts = input().split()   # 개행 포함 공백을 알아서 처리
    cmd = parts[0]

    if cmd == 'push':
        dq.append(parts[1])  # 문자열로 저장해도 출력에 문제 없음
    elif cmd == 'pop':
        out.append(dq.popleft() if dq else '-1')
    elif cmd == 'size':
        out.append(str(len(dq)))
    elif cmd == 'empty':
        out.append('0' if dq else '1')
    elif cmd == 'front':
        out.append(dq[0] if dq else '-1')
    else:  # back
        out.append(dq[-1] if dq else '-1')

sys.stdout.write('\n'.join(out))
```

---

## 이 코드에서 배울 수 있는 점

- `split()`은 개행(`\n`)을 포함한 공백을 자동으로 처리하므로, 명령 파싱이 깔끔해진다.
- 큐는 `deque`의 `append`/`popleft`를 쓰면 O(1)로 처리되어, `list.pop(0)` 같은 O(n) 병목을 피할 수 있다.
- 출력은 `out`에 모아서 `\n`.join(...) 후 `sys.stdout.write`로 한 번에 출력하면 대량 출력에서 안정적이다.
- “정방향 큐”로 구현하면 `front=dq[0]`, `back=dq[-1]`가 직관적으로 읽힌다.

---
