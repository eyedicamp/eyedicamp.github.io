---
layout: post
title: "[BOJ 28278] 스택 2"
date: 2026-02-06
excerpt: "백준 문제 풀이"
categories: [Algorithm, BOJ]
tags: [python, stack, sys, stdin, stdout, implementation]
---

## 문제 요약

정수 스택을 구현하고, N개의 명령을 처리한다.

- `1 X`: push X
- `2`: pop (없으면 -1)
- `3`: size
- `4`: empty (비었으면 1, 아니면 0)
- `5`: top (없으면 -1)

N이 최대 **1,000,000**이라서, **입력/출력 최적화**가 중요하다.

---

## 내가 작성한 코드 (정답)

```python
import sys

input = sys.stdin.readline

n = int(input())

stack = []

for _ in range(n):
    order = input()
    if order[0] == '1':
        x = int(order[2:])
        stack.append(x)
    elif order[0] == '2':
        if stack == []:
            print(-1)
        else:
            print(stack.pop())
    elif order[0] == '3':
        print(len(stack))
    elif order[0] == '4':
        if stack == []:
            print(1)
        else:
            print(0)
    elif order[0] == '5':
        if stack == []:
            print(-1)
        else:
            print(stack[-1])
```

---

## 왜 `order == '2'`가 안 됐나?

`sys.stdin.readline()`은 보통 **줄바꿈 문자 `\n`을 포함**해서 읽는다.

입력이 `2` 한 줄이면 실제로는:

- `order == '2\n'`

이라서 아래 비교는 실패한다.

```python
order = input()
if order == '2':   # order는 '2\n'이라서 False
    ...
```

반면 `order[0]`은 첫 글자만 보니까 `'2\n'`에서도 `'2'`가 되어 동작한다.

해결 방법은 줄바꿈을 제거하는 것.

```python
order = input().rstrip()   # 또는 .strip()
if order == '2':
    ...
```

---

## deque를 써야 할까?

이 문제는 **스택의 top(끝)에서만** `push/pop`을 한다.

- `list.append() / list.pop()`은 끝에서 O(1) (amortized)이고 일반적으로 매우 빠르다.
- `deque`도 양끝 O(1)이지만, “끝만 쓰는 스택”에서는 보통 `list`가 더 단순하고 빠른 편이다.

따라서 이 문제에서는 **list 스택이 충분히 좋은 선택**이다.

---

## 개선 포인트

1. `stack == []` 대신 `if not stack:`이 더 파이썬스럽고 읽기 쉽다.
2. `print()`를 매번 호출하면 I/O가 느려질 수 있으니, 출력은 리스트에 모아 한 번에 출력한다.
3. 입력 라인은 `rstrip()`으로 줄바꿈을 제거하면, 명령 비교가 명확해진다.

---

## 개선된 코드 (추천)

```python
import sys
input = sys.stdin.readline

n = int(input())
stack = []
out = []

for _ in range(n):
    line = input().rstrip()

    if line[0] == '1':          # "1 X"
        stack.append(int(line[2:]))
    elif line[0] == '2':        # pop
        out.append(str(stack.pop() if stack else -1))
    elif line[0] == '3':        # size
        out.append(str(len(stack)))
    elif line[0] == '4':        # empty
        out.append('1' if not stack else '0')
    else:                       # '5' top
        out.append(str(stack[-1] if stack else -1))

sys.stdout.write('\n'.join(out))
```

---

## 이 코드에서 배울 수 있는 점

- `rstrip()`으로 줄바꿈을 제거하면 `line == '2'` 같은 비교가 자연스럽게 된다.
- `if not stack:`은 빈 리스트 체크의 대표적인 파이썬 표현이다.
- 출력은 `out.append(...)`로 모아서 `\n`.join(...) 후 `sys.stdout.write`로 한 번에 찍는 게 대량 출력에서 유리하다.
- 스택은 `list`로 구현해도 충분하며, 끝에서의 `append/pop`은 스택 연산에 최적화되어 있다.

---
